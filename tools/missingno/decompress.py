import os
import sys
import utils
import differential


BLASTOISE = b"\x44\xB8\x55\x55\x57\xCE\x37\xAD\xAD\xA0\x8E\x35\x15\x05\x21\x39\x7B\x98\x56\x36\x7D\x5E\x61\xC3\x81\x68\xD9\xA9\x46\x88\x63\x82\xA3\x48\xA8\xD2\x89\x52\x11\x49\x4E\x54\x84\xA4\xE7\x61\x69\x8D\xE8\x94\x87\x22\x38\x55\x05\x2A\xA1\x4E\x2E\x21\x09\x42\xD5\x37\x50\x59\xDD\xEF\xAD\xF3\x5A\x30\xA8\xBA\x3C\x5D\xC2\x99\xA7\x2C\x38\x24\x31\xCF\x83\xA0\xC2\x9D\x1E\x10\x2C\x71\xA5\x41\x30\xB1\xB7\x83\x15\x04\x0D\x1C\x51\x31\x51\xCE\x84\x28\x20\x9C\x91\x28\x28\x27\x2C\x4C\x08\xC7\x64\x0E\x43\x1C\x49\x7A\x55\xA9\xBC\xAA\xC3\xD0\x53\xF1\xAE\x98\x3D\x1F\x18\x77\xBE\x3D\xF9\x3A\xD3\x9D\xE0\xAB\xD4\xE5\x7A\x39\x54\x18\x29\x6B\xB4\xD1\x7E\x41\x38\x5F\xED\x81\xA9\x0A\x90\xA3\x06\xA8\x65\x4E\x0A\x23\x22\x2E\xA1\x42\x25\xE9\x48\x42\x38\x7A\xA3\x2A\x21\x88\x97\x89\xA6\x15\x37\xA9\x26\x05\x21\x41\x8A\x60\x49\x62\x96\x36\xF5\x06\x7B\xBD\x0E\x25\x76\x07\xD8\xE1\x7D\x5D\x76\x26\xB4\x2C\x7E\x86\x9C\x88\x25\x06\xA3\x1A\x08\x21\xA2\xD5\x45\x06\xB4\xB8\x53\x08\xC5\xEF\x8D\x69\x60\x49\xA3\x04\x11\x41\x41\x29\xE2\xD5\x5A\xFB\xA0\x58\xA4\x25\x82\x2A\x29\x25\x45\x5B\xD6\x91\x88\xA9\x04\x87\x60\xE2\x96\x0D\x25\x21\x5D\x06\x30\x98\xBA\x46\xC2\x47\x05\x8B\x4C\xA8\x63\x65\x26\x2B\x09\x04\x22\x14\xCA\x3B\x10\x61\x76\x31\x99\x48\x4E\x9A\x14\x23\x65\x0C\x17\xA5\x8E\x9A\x8D\x54\x66\x70\xD7\x94\xE7\x58\xD1\xA6\x30\xAA\x05\x8E\x47\xCB\x6A\xA0\xA6\x38\x15\x38\xFD\x15\xA2\x17\x96\xA4\x50\x8C\xA3\x81\x07\x82\xA2\x90\x88\x55\xA1\x4E\xBA\xB4\xC1\x77\x52\x35\x53\xAD\x75\x05\x25\xAA\x22\x25\x48\xC8\x8E\x37\xE8\x68\x57\x86\x34\xBF\x6A\x39\x15\x55\xAF\xA0\x98\xF2\x6A\xA9\x8F\x2A\x7E\x10\x82\x9E\x9B\xC3\x7A\xA7\x2B\x9C\x5A\xA1\x51\x55\x10\x9C\x34\x72\xD4\x64\xAB\xF9\xA2\xF8\xA7\x0A\x44\xC6\x18\xFF\xF9\x83\xED\xED\x9C\x35\xA3\x18\x5F\xFF\xCE\x82\xFF\xF8\x47\x36\x31\x9D\x50\x35\xC4\x55\xFC\x72\x53\x16\x8A\x98\x7E\x92\x90\x91\x9A\x38\x26\x94\xFE\x0F\xA1\xFF\xE0\xF8\xB8\xF9\xAB\xC4\xAA\xBF\xFF\xCF\xFE\x1F\xF8\x7C\xFC\xBC\x68\xAF\xF5\x51\x35\x2F\xFF\xC1\x56\x1F\x87\xE1\xF9\x8A\xF5\x18\x59\x6D\x5F\xC0\xC0\xE3\xFB\x7E\xC6\x34\x31\xC2\xF8\x3E\x38\x40\x8B\x7E\x1F\xC9\xD7\x03"
MISSINGNO_A1 = b"\xDD\x1C\x7D\xE0\xC3\x7C\xE0\xC4\x79\xE0\xC5\x7B\xE0\xC1\xC9\x01\x68\x01\x04\x21\xA0\xC3\x3E\x7F\x22\x0D\x20\xFC\x05\x20\xF9\xC3\xD7\x3D\xE5\x3E\x79\x22\x3C\xCD\x4F\x19\x3C\x77\xE1\x11\x14\x00\x19\xE5\x3E\x7C\x22\x3E\x7F\xCD\x4F\x19\x36\x7C\xE1\x11\x14\x00\x19\x05\x20\xED\x3E\x7D\x22\x3E\x7A\xCD\x4F\x19\x36\x7E\xC9\x51\x22\x15\x20\xFC\xC9\xE5\x1A\xFE\x50\x20\x04\x44\x4D\xE1\xC9\xFE\x4E\x20\x12\x01\x28\x00\xF0\xF6\xCB\x57\x28\x03\x01\x14\x00\xE1\x09\xE5\xC3\xE8\x19\xFE\x4F\x20\x08\xE1\x21\xE1\xC4\xE5\xC3\xE8\x19\xA7\xCA\xEC\x19\xFE\x4C\xCA\x0A\x1B\xFE\x4B\xCA\xF8\x1A\xFE\x51\xCA\xB4\x1A\xFE\x49\xCA\xD5\x1A\xFE\x52\xCA\xF9\x19\xFE\x53\xCA\xFF\x19\xFE\x54\xCA\x1D\x1A\xFE\x5B\xCA\x11\x1A\xFE\x5E\xCA\x17\x1A\xFE\x5C\xCA\x0B\x1A\xFE\x5D\xCA\x05\x1A\xFE\x55\xCA\x7C\x1A\xFE\x56\xCA\x23\x1A\xFE\x57\xCA\xAD\x1A\xFE\x58\xCA\x95\x1A\xFE\x4A\xCA\x29\x1A\xFE\x5F\xCA\x91\x1A\xFE\x59\xCA\x2F\x1A\xFE\x5A\xCA\x35\x1A\x22\xCD\xD3\x38\x13\xC3\x56\x19\x44\x4D\xE1\x11\xF4\x19\x1B\xC9\x17\x96\x66\x22\x50\xD5\x11\x58\xD1\x18\x4C\xD5\x11\x4A\xD3\x18\x46\xD5\x11\x58\x1A\x18\x40\xD5\x11\x55\x1A\x18\x3A\xD5\x11\x60\x1A\x18\x34\xD5\x11\x63\x1A\x18\x2E\xD5\x11\x6A\x1A\x18\x28\xD5\x11\x6F\x1A\x18\x22\xD5\x11\x79\x1A\x18\x1C\xF0\xF3\xEE\x01\x18\x02\xF0\xF3\xD5\xA7\x20\x05\x11\x09\xD0\x18\x0B\x11\x72\x1A\xCD\x55\x19\x60\x69\x11\xDA\xCF\xCD\x55\x19\x60\x69\xD1\x13\xC3\x56\x19\x93\x8C\x50\x93\x91\x80\x88\x8D\x84\x91\x50\x8F\x82\x50\x91\x8E\x82\x8A\x84\x93\x50\x8F\x8E\x8A\xBA\x50\x75\x75\x50\x84\xAD\xA4\xAC\xB8\x7F\x50\xE1\xE2\x50\xD5\x44\x4D\x21\x8C\x1A\xCD\x40\x1B\x60\x69\xD1\x13\xC3\x56\x19\x17\xA3\x66\x22\x50\x36\xE8\xE1\xC9\xFA\x2B\xD1\xFE\x04\xCA\xA2\x1A\x3E\xEE\xEA\xF2\xC4\xCD\x3A\x1B\xCD\x98\x38\x3E\x7F\xEA\xF2\xC4\xE1\x11\xB3\x1A\x1B\xC9\x50\xD5\x3E\xEE\xEA\xF2\xC4\xCD\x3A\x1B\xCD\x98\x38\x21\xA5\xC4\x01\x12\x04\xCD\xC4\x18\x0E\x14\xCD\x39\x37\xD1\x21\xB9\xC4\xC3\xE8\x19\xD5\x3E\xEE\xEA\xF2\xC4\xCD\x3A\x1B\xCD\x98\x38\x21\x69\xC4\x01\x12\x07\xCD\xC4\x18\x0E\x14\xCD\x39\x37\xD1\xE1\x21\x7D\xC4\xE5\xC3\xE8\x19\x3E\xEE\xEA\xF2\xC4\xCD\x3A\x1B\xD5\xCD\x98\x38\xD1\x3E\x7F\xEA\xF2\xC4\xD5\xCD\x18\x1B\xCD\x18\x1B\x21\xE1\xC4\xD1\xC3\xE8\x19\x21\xB8\xC4\x11\xA4\xC4\x06\x3C\x2A\x12\x13\x05\x20\xFA\x21\xE1\xC4\x3E\x7F\x06\x12\x22\x05\x20\xFC\x06\x05\xCD\xAF\x20\x05\x20\xFA\xC9\xC5\xCD\xD7\x3D\xC1\xC9\xFA\x58\xD3\xF5\xCB\xCF\x5F\xF0\xF4\xAB\xEA\x58\xD3\x79\xEA\x3A\xCC\x78\xEA\x3B\xCC\x2A\xFE\x50\x20\x05\xF1\xEA\x58\xD3\xC9\xE5\xFE\x17\xCA\xA3\x1C\xFE\x0E\xD2\x31\x1C\x21\xC1\x1C\xC5\x87\x06\x00\x4F\x09\xC1\x2A\x66\x6F\xE9\xE1\x2A\x5F\x2A\x57\x2A\x47\x2A\x4F\xE5\x62\x6B\xCD\x22\x19\xE1\x18\xCB\xE1\x54\x5D\x60\x69\xCD\x55\x19\x62\x6B\x23\x18\xBE\xE1\x2A\x5F\x2A\x57\xE5\x60\x69\xCD\x55\x19\xE1\x18\xB0\xE1\x2A\x5F\x2A\x57\x2A\xE5\x60\x69\x4F\xCD\xCD\x15\x44\x4D\xE1\x18\x9E\xE1\x2A\xEA\x3A\xCC\x4F\x2A\xEA\x3B\xCC\x47\xC3\x55\x1B\xE1\x01\xE1\xC4\xC3\x55\x1B\xFA\x2B\xD1\xFE\x04\xCA\x9A\x1C\x3E\xEE\xEA\xF2\xC4\xC5\xCD\x98\x38\xC1\x3E\x7F\xEA\xF2\xC4\xE1\xC3\x55\x1B\x3E\x7F\xEA\xF2\xC4\xCD\x18\x1B\xCD\x18\x1B\xE1\x01\xE1\xC4\xC3\x55\x1B\xE1\x11\x55\x1B\xD5\xE9\xE1\x2A\x5F\x2A\x57\x2A\xE5\x60\x69\x47\xE6\x0F\x4F\x78\xE6\xF0\xCB\x37\xCB\xF7\x47\xCD\x5F\x3C\x44\x4D\xE1\xC3\x55\x1B\xC5\xCD\x9A\x01\xF0\xB4\xE6\x03\x20\x05\x0E\x1E\xCD\x39\x37\xC1\xE1\xC3\x55\x1B\xE1\xC5\x2B\x2A\x47\xE5\x21\x64\x1C\x2A\xB8\x28\x03\x23\x18\xF9\xFE\x14\x28\x14\xFE\x15\x28\x10\xFE\x16\x28\x0C\x7E\xCD\xB1\x23\xCD\x48\x37\xE1\xC1\xC3\x55\x1B\xD5\x7E\xCD\xD0\x13\xD1\xE1\xC1\xC3\x55\x1B\x0B\x86\x12\x9A\x0E\x91\x0F\x86\x10\x89\x11\x94\x13\x98\x14\xA8\x15\x97\x16\x78\xE1\x2A\x57\xE5\x60\x69\x3E\x75\x22\xD5\xCD\x9A\x01\xD1\xF0\xB4\xE6\x03\x20\x05\x0E\x0A\xCD\x39\x37\x15\x20\xEA\x44\x4D\xE1\xC3\x55\x1B\xC5\xCD\x98\x38\xC1\xE1\xC3\x55\x1B\xE1\xF0\xB8\xF5\x2A\x5F\x2A\x57\x2A\xE0\xB8\xEA\x00\x20\xE5\x6B\x62\xCD\x40\x1B\xE1\xF1\xE0\xB8\xEA\x00\x20\xC3\x55\x1B\x8A\x1B\x97\x1B\xA5\x1B\xB7\x1B\x78\x1B\xC5\x1B\xCC\x1B\xE7\x1B\xF9\x1B\xFF\x1B\x1D\x1C\x31\x1C\x78\x1C\x9A\x1C\xAF\xCB\x3C\xCB\x1F\xCB\x3C\xCB\x1F\xCB\x3C\xCB\x1F\xB5\x6F\x78\xB4\x67\xC9\x3E\x7F\x18\x01\x7D\x11\x00\x04\x6B\x22\x1D\x20\xFC\x15\x20\xF9\xC9\xF0\xD0\xA7\xC8\x47\xAF\xE0\xD0\x05\x20\x24\x21\xFC\xCB\xF0"
UNIMPLEMENTED = RuntimeError("Unimplemented")


class Decompressor():
    LENGTH_ENCODING_OFFSET_LIST = [
        0x01,0x00,0x03,0x00,0x07,0x00,0x0F,0x00,0x1F,0x00,0x3F,0x00,0x7F,0x00,0xFF,0x00,0xFF,0x01,0xFF,0x03,0xFF,0x07,0xFF,0x0F,0xFF,0x1F,0xFF,0x3F,0xFF,0x7F,0xFF,0xFF
    ]
    # for xor chunks with sprite flipped flag
    REVERSE_NYBBLE_TABLE = [
        0x0, 0x8, 0x4, 0xc, 0x2, 0xa, 0x6, 0xe, 0x1, 0x9, 0x5, 0xd, 0x3, 0xb, 0x7, 0xf
    ]


    def __init__(self, sprite: bytes) -> None:
        self.reader = utils.ByteReader(sprite)
        # available SRAM space starting from sSpriteBuffer1
        self.output = bytearray(b'\x00' * (0xC000 - 0xA000))
        self.output_ptr = None
        self.output_bit_offset = 0
        self.cur_pos_y = 0
        self.cur_pos_x = 0
        self.sprite_flipped = None


    def print_state(self):
        print(f"==========================================")
        print(f"OutputPtr: {0xA000+self.output_ptr:04x}")
        print(f"OutputBitOffset: {self.output_bit_offset}")
        print(f"CurPosX: {self.cur_pos_x}")
        print(f"CurPosY: {self.cur_pos_y}")
        print(f"Output: {self.output}")


    def write_output(self, bits: int):
        b = self.output[self.output_ptr]
        b = (b) | ((bits & 0b00000011) << (self.output_bit_offset*2))
        self.output[self.output_ptr] = b


    def move_to_next_buffer_position(self) -> bool:
        self.cur_pos_y += 1
        if self.cur_pos_y >= self.height:
            # curColumnDone
            self.cur_pos_y = 0
            if self.output_bit_offset != 0:
                self.output_bit_offset -= 1
                self.output_ptr = self.output_ptr_cached
                return

            # bitOffsetsDone
            self.output_bit_offset = 3
            self.cur_pos_x += 8
            if self.cur_pos_x >= self.width:
                # allColumnsDone
                # this does cursed things with the stack
                self.cur_pos_x = 0
                return True

            self.output_ptr += 1
            self.output_ptr_cached = self.output_ptr
        else:
            self.output_ptr += 1

        return False


    def read_rl_encoded_zeros_count(self) -> int:
        zero_count = 0

        while True:
            if self.reader.read_bit() == 0:
                break
            zero_count += 1

        print("Zeros:", zero_count)
        offset = self.LENGTH_ENCODING_OFFSET_LIST[zero_count * 2] | (self.LENGTH_ENCODING_OFFSET_LIST[zero_count * 2 + 1] << 8)
        print("Offset:", offset)

        num_of_zeros = 0
        for _ in range(0, zero_count+1):
            num_of_zeros <<= 1
            num_of_zeros |= self.reader.read_bit()
        print(f"{num_of_zeros:x}")

        iterations = num_of_zeros + offset
        return iterations


    def reset_output_ptrs(self):
        if (self.flags & 0x1) == 0:
            self.output_ptr = 0x310
            self.output_ptr_cached = 0x188
        else:
            self.output_ptr = 0x188
            self.output_ptr_cached = 0x310


    def unpack_mode2(self):
        self.reset_output_ptrs()
        self.cur_pos_x = 0
        self.cur_pos_y = 0

        data_len = (self.width // 8) * self.height
        decoder = differential.DifferentialDecoder(
            self.output[self.output_ptr_cached:(self.output_ptr_cached+data_len)],
            self.width,
            self.height,
            invert=False)
        output = decoder.decode()
        self.output[self.output_ptr_cached:(self.output_ptr_cached+data_len)] = output
        print("Chunk1 decoded differential data:", output)

        # XorSpriteChunks below

        decoder = differential.DifferentialDecoder(
            self.output[self.output_ptr:(self.output_ptr+data_len)],
            self.width,
            self.height,
            invert=self.sprite_flipped)
        output = decoder.decode()
        self.output[self.output_ptr:(self.output_ptr+data_len)] = output
        print("Chunk2 decoded differential data:", output)

        source = self.output_ptr
        destination = self.output_ptr_cached

        while True:
            if self.sprite_flipped:
                raise UNIMPLEMENTED

            b1 = self.output[source]
            b2 = self.output[destination]
            result = b1 ^ b2
            self.output[destination] = result

            source += 1
            destination += 1

            self.cur_pos_y += 1
            if self.cur_pos_y >= self.height:
                self.cur_pos_y = 0
                self.cur_pos_x += 8
                if self.cur_pos_x >= self.width:
                    self.cur_pos_x = 0
                    break

        res = self.output[self.output_ptr_cached:self.output_ptr_cached+data_len]
        print("XOR output:", res)

        with open('BLASTOISE.bin', 'wb') as f:
            f.write(res)


    def unpack_xor(self):
        raise UNIMPLEMENTED


    def unpack_differential(self):
        raise UNIMPLEMENTED


    def decompress(self) -> bytearray:
        sizebyte = self.reader.read_byte()
        self.width = (sizebyte & 0xF) * 8
        self.height = ((sizebyte >> 4) & 0xF) * 8
        print(f"Sprite dimensions: {self.width}, {self.height}")

        self.flags = self.reader.read_bit()
        print(f"Starting flags: {self.flags:x}")
        self.output_bit_offset = 3

        while True:
            self.output_ptr = 0x188
            if self.flags & 0x1:
                self.output_ptr = 0x310
            self.output_ptr_cached = self.output_ptr
            print(f"Offset: {self.output_ptr:x}")

            # read unpacking mode when this is the last sprite
            if self.flags & 0x2:
                if self.reader.read_bit() == 0:
                    self.unpacking_mode = 0
                else:
                    self.unpacking_mode = 1 + self.reader.read_bit()
                print("Unpacking mode:", self.unpacking_mode)

            # if first bit is 0, input starts with zeros
            # handle this case
            if self.reader.read_bit() == 0:
                count = self.read_rl_encoded_zeros_count()
                for _ in range(0, count):
                    # write '00'
                    self.write_output(0b00)
                    if self.move_to_next_buffer_position():
                        break

            should_stop = False
            while not should_stop:
                # self.print_state()

                mode = (self.reader.read_bit()<<1) | self.reader.read_bit()
                if mode == 0b00:
                    count = self.read_rl_encoded_zeros_count()
                    for _ in range(0, count):
                        # write '00'
                        self.write_output(0b00)
                        should_stop = self.move_to_next_buffer_position()
                        # this breaks from the inner for, not the while
                        if should_stop:
                            break
                else:
                    # simply send the bits to the output
                    self.write_output(mode)
                    should_stop = self.move_to_next_buffer_position()

            print("POST RLE:")
            print(self.output)
            with open("MISSINGNO_OUT.bin", "wb") as f:
                f.write(self.output)

            # post RLE run, after all rows/columns are done
            # if this was the last sprite, exit
            if self.flags & 0b10:
                break

            # there's one more sprite to decompress, set flag and continue
            # after the next iteration is done, move on to UnpackSprite
            self.flags ^= 0b01
            self.flags |= 0b10

        # - UnpackSprite
        if self.unpacking_mode == 2:
            self.unpack_mode2()
        elif self.unpacking_mode == 1:
            self.unpack_xor()
        else:
            self.unpack_differential()

        return self.output


def main():
    decomp = Decompressor(MISSINGNO_A1)
    print(decomp.decompress())


if __name__ == "__main__":
    main()




